; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35219.0 

	TITLE	c:\anka2project\anka2project\source\binary\vs_files\userinterface\release\markimage.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@ ; `string'
PUBLIC	??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@ ; `string'
PUBLIC	??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@ ; `string'
PUBLIC	??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@ ; `string'
PUBLIC	??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDa@ ; `string'
PUBLIC	??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6@ ; `string'
PUBLIC	??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@ ; `string'
PUBLIC	??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@ ; `string'
PUBLIC	??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks@ ; `string'
PUBLIC	??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@ ; `string'
PUBLIC	??_R2CGuildMarkImage@@8				; CGuildMarkImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGuildMarkImage@@8		; CGuildMarkImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CGuildMarkImage@@8				; CGuildMarkImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCGuildMarkImage@@@8			; CGuildMarkImage `RTTI Type Descriptor'
PUBLIC	??_R4CGuildMarkImage@@6B@			; CGuildMarkImage::`RTTI Complete Object Locator'
PUBLIC	?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A	; CSingleton<CLZO>::ms_singleton
PUBLIC	??_7CGuildMarkImage@@6B@			; CGuildMarkImage::`vftable'
EXTRN	_lzo1x_999_compress:PROC
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	?GetWorkMemory@CLZO@@QAEPAEXZ:PROC		; CLZO::GetWorkMemory
EXTRN	_lzo1x_decompress_safe:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	__imp__ilSetPixels@36:PROC
EXTRN	__imp__ilTexImage@28:PROC
EXTRN	__imp__ilSave@8:PROC
;	COMDAT ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A DD 01H DUP (?) ; CSingleton<CLZO>::ms_singleton
_BSS	ENDS
;	COMDAT ??_7CGuildMarkImage@@6B@
CONST	SEGMENT
??_7CGuildMarkImage@@6B@ DD FLAT:??_R4CGuildMarkImage@@6B@ ; CGuildMarkImage::`vftable'
	DD	FLAT:??_ECGuildMarkImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CGuildMarkImage@@6B@
rdata$r	SEGMENT
??_R4CGuildMarkImage@@6B@ DD 00H			; CGuildMarkImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGuildMarkImage@@@8
	DD	FLAT:??_R3CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGuildMarkImage@@@8
data$rs	SEGMENT
??_R0?AVCGuildMarkImage@@@8 DD FLAT:??_7type_info@@6B@	; CGuildMarkImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGuildMarkImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CGuildMarkImage@@8
rdata$r	SEGMENT
??_R3CGuildMarkImage@@8 DD 00H				; CGuildMarkImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGuildMarkImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGuildMarkImage@@8 DD FLAT:??_R0?AVCGuildMarkImage@@@8 ; CGuildMarkImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGuildMarkImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CGuildMarkImage@@8
rdata$r	SEGMENT
??_R2CGuildMarkImage@@8 DD FLAT:??_R1A@?0A@EA@CGuildMarkImage@@8 ; CGuildMarkImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@
CONST	SEGMENT
??_C@_0CK@BGEKGKPD@SGuildMarkBlock?3?3Compress?3?5Erro@ DB 'SGuildMarkBlo'
	DB	'ck::Compress: Error! %u > %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks@
CONST	SEGMENT
??_C@_0CA@JFLGBLGM@CGuildMarkImage?3?3BuildAllBlocks@ DB 'CGuildMarkImage'
	DB	'::BuildAllBlocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@
CONST	SEGMENT
??_C@_0FG@JNKKBOCL@CGuildMarkImage?3?3CopyBlockFromC@ DB 'CGuildMarkImage'
	DB	'::CopyBlockFromCompressedData: image corrupted, decompressed '
	DB	'size = %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@
CONST	SEGMENT
??_C@_0FG@IJMAAEIA@CGuildMarkImage?3?3CopyBlockFromC@ DB 'CGuildMarkImage'
	DB	'::CopyBlockFromCompressedData: cannot decompress, compressed '
	DB	'size = %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6@
CONST	SEGMENT
??_C@_0BG@PFKANOHB@PutMark?5pos?5?$CFu?5?$CFux?$CFu?6@ DB 'PutMark pos %u'
	DB	' %ux%u', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDa@
CONST	SEGMENT
??_C@_0DM@NNKMJGHN@CGuildMarkImage?3?3CopyMarkFromDa@ DB 'CGuildMarkImage'
	DB	'::CopyMarkFromData: Invalid mark position %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@
CONST	SEGMENT
??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@ DB 'CGuildMark'
	DB	'Image: %s height must be %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@
CONST	SEGMENT
??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@ DB 'CGuildMar'
	DB	'kImage: %s width must be %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@
CONST	SEGMENT
??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@ DB 'CGuildMarkIma'
	DB	'ge: cannot open file for writing %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@
CONST	SEGMENT
??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@ DB 'CGuildMarkImag'
	DB	'e: cannot initialize image', 00H		; `string'
PUBLIC	_printf
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> >::deallocate
PUBLIC	??$destroy_at@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@@std@@YAXQAU?$pair@$$CBEPBUSGuildMarkBlock@@@0@@Z ; std::destroy_at<std::pair<unsigned char const ,SGuildMarkBlock const *> >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >
PUBLIC	??$destroy@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@1@QAU?$pair@$$CBEPBUSGuildMarkBlock@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >::destroy<std::pair<unsigned char const ,SGuildMarkBlock const *> >
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> *>
PUBLIC	??$addressof@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@@std@@YAPAU?$pair@$$CBEPBUSGuildMarkBlock@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned char const ,SGuildMarkBlock const *> >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBEPBUSGuildMarkBlock@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned char const ,SGuildMarkBlock const *>,void *> > >
PUBLIC	?Instance@?$CSingleton@VCLZO@@@@SAAAVCLZO@@XZ	; CSingleton<CLZO>::Instance
PUBLIC	?Compress@SGuildMarkBlock@@QAEXPBK@Z		; SGuildMarkBlock::Compress
PUBLIC	?CopyFrom@SGuildMarkBlock@@QAEXPBEKK@Z		; SGuildMarkBlock::CopyFrom
PUBLIC	?GetCRC@SGuildMarkBlock@@QBEKXZ			; SGuildMarkBlock::GetCRC
PUBLIC	?GetBlockCRCList@CGuildMarkImage@@QAEXPAK@Z	; CGuildMarkImage::GetBlockCRCList
PUBLIC	?BuildAllBlocks@CGuildMarkImage@@AAEXXZ		; CGuildMarkImage::BuildAllBlocks
PUBLIC	?SaveBlockFromCompressedData@CGuildMarkImage@@QAE_NKPBEK@Z ; CGuildMarkImage::SaveBlockFromCompressedData
PUBLIC	?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z		; CGuildMarkImage::GetData
PUBLIC	?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z		; CGuildMarkImage::PutData
PUBLIC	?Load@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Load
PUBLIC	?Build@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Build
PUBLIC	?Save@CGuildMarkImage@@QAE_NPBD@Z		; CGuildMarkImage::Save
PUBLIC	?Create@CGuildMarkImage@@QAEXXZ			; CGuildMarkImage::Create
PUBLIC	?Destroy@CGuildMarkImage@@QAEXXZ		; CGuildMarkImage::Destroy
PUBLIC	??1CGuildMarkImage@@UAE@XZ			; CGuildMarkImage::~CGuildMarkImage
PUBLIC	??_GCGuildMarkImage@@UAEPAXI@Z			; CGuildMarkImage::`scalar deleting destructor'
PUBLIC	??0CGuildMarkImage@@QAE@XZ			; CGuildMarkImage::CGuildMarkImage
EXTRN	??_ECGuildMarkImage@@UAEPAXI@Z:PROC		; CGuildMarkImage::`vector deleting destructor'
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?Destroy@CGuildMarkImage@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CGuildMarkImage@@QAEXXZ PROC			; CGuildMarkImage::Destroy, COMDAT
; _this$ = ecx

; 39   : 	if (INVALID_HANDLE == m_uImg)

  00000	83 b9 c4 07 5f
	00 ff		 cmp	 DWORD PTR [ecx+6227908], -1
  00007	56		 push	 esi
  00008	8d b1 c4 07 5f
	00		 lea	 esi, DWORD PTR [ecx+6227908]
  0000e	74 0f		 je	 SHORT $LN1@Destroy

; 40   : 		return;
; 41   : 
; 42   : 	ilDeleteImages(1, &m_uImg);

  00010	56		 push	 esi
  00011	6a 01		 push	 1
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilDeleteImages@8

; 43   : 	m_uImg = INVALID_HANDLE;

  00019	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN1@Destroy:

; 44   : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?Destroy@CGuildMarkImage@@QAEXXZ ENDP			; CGuildMarkImage::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?Create@CGuildMarkImage@@QAEXXZ
_TEXT	SEGMENT
?Create@CGuildMarkImage@@QAEXXZ PROC			; CGuildMarkImage::Create, COMDAT
; _this$ = ecx

; 48   : 	if (INVALID_HANDLE != m_uImg)

  00000	81 c1 c4 07 5f
	00		 add	 ecx, 6227908		; 005f07c4H
  00006	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00009	75 09		 jne	 SHORT $LN1@Create

; 49   : 		return;
; 50   : 
; 51   : 	ilGenImages(1, &m_uImg);

  0000b	51		 push	 ecx
  0000c	6a 01		 push	 1
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGenImages@8
$LN1@Create:

; 52   : }

  00014	c3		 ret	 0
?Create@CGuildMarkImage@@QAEXXZ ENDP			; CGuildMarkImage::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?Save@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Save@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Save, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 56   : 	ilEnable(IL_FILE_OVERWRITE);

  00004	68 20 06 00 00	 push	 1568			; 00000620H
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 57   : 	ilBindImage(m_uImg);

  00011	ff b6 c4 07 5f
	00		 push	 DWORD PTR [esi+6227908]
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 58   : 
; 59   : 	if (!ilSave(IL_TGA, (const ILstring)c_szFileName))

  0001d	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00020	68 2d 04 00 00	 push	 1069			; 0000042dH
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSave@8
  0002b	84 c0		 test	 al, al

; 60   : 		return false;

  0002d	5e		 pop	 esi
  0002e	0f 95 c0	 setne	 al

; 61   : 
; 62   : 	return true;
; 63   : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?Save@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Save
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?Build@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Build@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Build, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 67   : 	Destroy();

  00006	e8 00 00 00 00	 call	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy

; 68   : 	Create();

  0000b	8b ce		 mov	 ecx, esi
  0000d	e8 00 00 00 00	 call	 ?Create@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Create

; 69   : 
; 70   : 	ilBindImage(m_uImg);

  00012	ff b6 c4 07 5f
	00		 push	 DWORD PTR [esi+6227908]
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 71   : 	ilEnable(IL_ORIGIN_SET);

  0001e	68 00 06 00 00	 push	 1536			; 00000600H
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 72   : 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

  00029	68 02 06 00 00	 push	 1538			; 00000602H
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilOriginFunc@4

; 73   : 
; 74   : 	BYTE * data = (BYTE *) malloc(sizeof(Pixel) * WIDTH * HEIGHT);

  00034	68 00 00 10 00	 push	 1048576			; 00100000H
  00039	e8 00 00 00 00	 call	 _malloc

; 75   : 	memset(data, 0, sizeof(Pixel) * WIDTH * HEIGHT);

  0003e	68 00 00 10 00	 push	 1048576			; 00100000H
  00043	8b f0		 mov	 esi, eax
  00045	6a 00		 push	 0
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 _memset
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 76   : 
; 77   : 	if (!ilTexImage(WIDTH, HEIGHT, 1, 4, IL_BGRA, IL_UNSIGNED_BYTE, data))

  00050	56		 push	 esi
  00051	68 01 14 00 00	 push	 5121			; 00001401H
  00056	68 e1 80 00 00	 push	 32993			; 000080e1H
  0005b	6a 04		 push	 4
  0005d	6a 01		 push	 1
  0005f	68 00 02 00 00	 push	 512			; 00000200H
  00064	68 00 02 00 00	 push	 512			; 00000200H
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilTexImage@28
  0006f	84 c0		 test	 al, al
  00071	75 14		 jne	 SHORT $LN2@Build

; 78   : 	{
; 79   : 		sys_err("CGuildMarkImage: cannot initialize image");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CFLIGMKO@CGuildMarkImage?3?5cannot?5initial@
  00078	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0007d	83 c4 04	 add	 esp, 4

; 80   : 		return false;

  00080	32 c0		 xor	 al, al
  00082	5e		 pop	 esi

; 88   : 		return false;
; 89   : 
; 90   : 	return true;
; 91   : }

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN2@Build:

; 81   : 	}
; 82   : 
; 83   : 	free(data);

  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _free
  0008d	83 c4 04	 add	 esp, 4

; 84   : 
; 85   : 	ilEnable(IL_FILE_OVERWRITE);

  00090	68 20 06 00 00	 push	 1568			; 00000620H
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 86   : 
; 87   : 	if (!ilSave(IL_TGA, (const ILstring)c_szFileName))

  0009b	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0009e	68 2d 04 00 00	 push	 1069			; 0000042dH
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSave@8
  000a9	84 c0		 test	 al, al
  000ab	5e		 pop	 esi
  000ac	0f 95 c0	 setne	 al

; 88   : 		return false;
; 89   : 
; 90   : 	return true;
; 91   : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
?Build@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Build
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?Load@CGuildMarkImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Load@CGuildMarkImage@@QAE_NPBD@Z PROC			; CGuildMarkImage::Load, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 95   : 	Destroy();

  00007	e8 00 00 00 00	 call	 ?Destroy@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Destroy

; 96   : 	Create();	

  0000c	8b cf		 mov	 ecx, edi
  0000e	e8 00 00 00 00	 call	 ?Create@CGuildMarkImage@@QAEXXZ ; CGuildMarkImage::Create

; 97   : 
; 98   : 	ilBindImage(m_uImg);

  00013	ff b7 c4 07 5f
	00		 push	 DWORD PTR [edi+6227908]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 99   : 	ilEnable(IL_ORIGIN_SET);

  0001f	68 00 06 00 00	 push	 1536			; 00000600H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilEnable@4

; 100  : 	ilOriginFunc(IL_ORIGIN_UPPER_LEFT);

  0002a	68 02 06 00 00	 push	 1538			; 00000602H
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilOriginFunc@4

; 101  : 
; 102  : 	if (!ilLoad(IL_TYPE_UNKNOWN, (const ILstring) c_szFileName))

  00035	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
  00038	56		 push	 esi
  00039	6a 00		 push	 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilLoad@8
  00041	84 c0		 test	 al, al
  00043	75 2a		 jne	 SHORT $LN3@Load

; 103  : 	{
; 104  : 		Build(c_szFileName);

  00045	56		 push	 esi
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?Build@CGuildMarkImage@@QAE_NPBD@Z ; CGuildMarkImage::Build

; 105  : 		
; 106  : 		if (!Load(c_szFileName))

  0004d	56		 push	 esi
  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?Load@CGuildMarkImage@@QAE_NPBD@Z ; CGuildMarkImage::Load
  00055	84 c0		 test	 al, al
  00057	75 16		 jne	 SHORT $LN3@Load

; 107  : 		{
; 108  : 			sys_err("CGuildMarkImage: cannot open file for writing %s", c_szFileName);

  00059	56		 push	 esi
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LCKJIDBG@CGuildMarkImage?3?5cannot?5open?5fi@
  0005f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00064	83 c4 08	 add	 esp, 8

; 109  : 			return false;

  00067	32 c0		 xor	 al, al
  00069	5f		 pop	 edi

; 129  : }

  0006a	5e		 pop	 esi
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN3@Load:

; 110  : 		}
; 111  : 	}
; 112  : 
; 113  : 	if (ilGetInteger(IL_IMAGE_WIDTH) != WIDTH)	

  0006f	68 e4 0d 00 00	 push	 3556			; 00000de4H
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGetInteger@4
  0007a	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0007f	74 1b		 je	 SHORT $LN4@Load

; 114  : 	{
; 115  : 		sys_err("CGuildMarkImage: %s width must be %u", c_szFileName, WIDTH);

  00081	68 00 02 00 00	 push	 512			; 00000200H
  00086	56		 push	 esi
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@POGBMAHP@CGuildMarkImage?3?5?$CFs?5width?5must?5@
  0008c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 		return false;

  00094	32 c0		 xor	 al, al
  00096	5f		 pop	 edi

; 129  : }

  00097	5e		 pop	 esi
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
$LN4@Load:

; 117  : 	}
; 118  : 
; 119  : 	if (ilGetInteger(IL_IMAGE_HEIGHT) != HEIGHT)

  0009c	68 e5 0d 00 00	 push	 3557			; 00000de5H
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGetInteger@4
  000a7	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  000ac	74 1b		 je	 SHORT $LN5@Load

; 120  : 	{
; 121  : 		sys_err("CGuildMarkImage: %s height must be %u", c_szFileName, HEIGHT);

  000ae	68 00 02 00 00	 push	 512			; 00000200H
  000b3	56		 push	 esi
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@ENKENEAG@CGuildMarkImage?3?5?$CFs?5height?5must@
  000b9	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 122  : 		return false;

  000c1	32 c0		 xor	 al, al
  000c3	5f		 pop	 edi

; 129  : }

  000c4	5e		 pop	 esi
  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
$LN5@Load:

; 123  : 	}
; 124  : 
; 125  : 	ilConvertImage(IL_BGRA, IL_UNSIGNED_BYTE);

  000c9	68 01 14 00 00	 push	 5121			; 00001401H
  000ce	68 e1 80 00 00	 push	 32993			; 000080e1H
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilConvertImage@8

; 126  : 
; 127  : 	BuildAllBlocks();

  000d9	8b cf		 mov	 ecx, edi
  000db	e8 00 00 00 00	 call	 ?BuildAllBlocks@CGuildMarkImage@@AAEXXZ ; CGuildMarkImage::BuildAllBlocks
  000e0	5f		 pop	 edi

; 128  : 	return true;

  000e1	b0 01		 mov	 al, 1

; 129  : }

  000e3	5e		 pop	 esi
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
?Load@CGuildMarkImage@@QAE_NPBD@Z ENDP			; CGuildMarkImage::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$dead$ = 16					; size = 4
_height$dead$ = 20					; size = 4
_data$ = 24						; size = 4
?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z PROC		; CGuildMarkImage::PutData, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 	ilBindImage(m_uImg);

  00003	ff b1 c4 07 5f
	00		 push	 DWORD PTR [ecx+6227908]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 134  : 	ilSetPixels(x, y, 0, width, height, 1, IL_BGRA, IL_UNSIGNED_BYTE, data);

  0000f	ff 75 18	 push	 DWORD PTR _data$[ebp]
  00012	68 01 14 00 00	 push	 5121			; 00001401H
  00017	68 e1 80 00 00	 push	 32993			; 000080e1H
  0001c	6a 01		 push	 1
  0001e	6a 30		 push	 48			; 00000030H
  00020	6a 40		 push	 64			; 00000040H
  00022	6a 00		 push	 0
  00024	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilSetPixels@36

; 135  : }

  00030	5d		 pop	 ebp
  00031	c2 14 00	 ret	 20			; 00000014H
?PutData@CGuildMarkImage@@QAEXIIIIPAX@Z ENDP		; CGuildMarkImage::PutData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\MarkImage.cpp
;	COMDAT ?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$dead$ = 16					; size = 4
_height$dead$ = 20					; size = 4
_data$ = 24						; size = 4
?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z PROC		; CGuildMarkImage::GetData, COMDAT
; _this$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 139  : 	ilBindImage(m_uImg);

  00003	ff b1 c4 07 5f
	00		 push	 DWORD PTR [ecx+6227908]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 140  : 	ilCopyPixels(x, y, 0, width, height, 1, IL_BGRA, IL_UNSIGNED_BYTE, data);	

  0000f	ff 75 18	 push	 DWORD PTR _data$[ebp]
  00012	68 01 14 00 00	 push	 5121			; 00001401H
  00017	68 e1 80 00 00	 push	 32993			; 000080e1H
  0001c	6a 01		 push	 1
  0001e	6a 30		 push	 48			; 00000030H
  00020	6a 40		 push	 64			; 00000040H
  00022	6a 00		 push	 0
  00024	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _x$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilCopyPixels@36

; 141  : }

  00030	5d		 pop	 ebp
  00031	c2 14 00	 ret	 20			; 00000014H
?GetData@CGuildMarkImage@@QAEXIIIIPAX@Z ENDP		; CGuildMarkImage::GetData
_TEXT	ENDS
END
