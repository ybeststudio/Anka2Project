; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35219.0 

	TITLE	c:\anka2project\anka2project\source\binary\vs_files\userinterface\release\processcrc.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__ReadProcessMemory@20:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__Module32Next@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__Module32First@8:PROC
EXTRN	?GetExcutedFileName@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetExcutedFileName
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__CreateToolhelp32Snapshot@8:PROC
	ORG $+3
?abCRCXorTable@@3PAEA DB 066H				; abCRCXorTable
	DB	01eH
	DB	0bcH
	DB	02cH
	DB	027H
	DB	0c9H
	DB	02bH
	DB	05H
PUBLIC	?GetProcessCRCMagicCubePiece@@YAEXZ		; GetProcessCRCMagicCubePiece
PUBLIC	?BuildProcessCRC@@YAXXZ				; BuildProcessCRC
PUBLIC	?__GetExeCRC@@YA_NAAK0@Z			; __GetExeCRC
PUBLIC	?GetProcessMemoryCRC@@YAKPBX@Z			; GetProcessMemoryCRC
PUBLIC	?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z ; GetProcessInformation
PUBLIC	?stristr@@YAPBDPBD0@Z				; stristr
?abCRCMagicCube@@3PAEA DB 08H DUP (?)			; abCRCMagicCube
?bMagicCubeIdx@@3EA DB 01H DUP (?)			; bMagicCubeIdx
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__GetExeCRC@@YA_NAAK0@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$?__GetExeCRC@@YA_NAAK0@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$?__GetExeCRC@@YA_NAAK0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__GetExeCRC@@YA_NAAK0@Z$0
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
_TEXT	SEGMENT
_ppvAddress$GSCopy$1$ = -608				; size = 4
_exeFileName$GSCopy$1$ = -604				; size = 4
_me32$16 = -600						; size = 548
_filename$17 = -44					; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z PROC ; GetProcessInformation, COMDAT
; _exeFileName$ = ecx
; _ppvAddress$ = edx

; 22   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec 50 02 00
	00		 sub	 esp, 592		; 00000250H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 95 a0 fd ff
	ff		 mov	 DWORD PTR _ppvAddress$GSCopy$1$[ebp], edx
  00047	89 8d a4 fd ff
	ff		 mov	 DWORD PTR _exeFileName$GSCopy$1$[ebp], ecx

; 23   : 	HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  00053	50		 push	 eax
  00054	6a 08		 push	 8
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateToolhelp32Snapshot@8
  0005c	8b f0		 mov	 esi, eax

; 24   : 	if (hModuleSnap != INVALID_HANDLE_VALUE) 

  0005e	83 fe ff	 cmp	 esi, -1
  00061	0f 84 68 01 00
	00		 je	 $LN96@GetProcess
  00067	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 860  :         _My_data._Mysize = 0;

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _filename$17[ebp+16], 0

; 493  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00071	0f 11 45 d4	 movups	 XMMWORD PTR _filename$17[ebp], xmm0

; 861  :         _My_data._Myres  = _Small_string_capacity;

  00075	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _filename$17[ebp+20], 15 ; 0000000fH

; 862  :         _My_data._Activate_SSO_buffer();
; 863  : 
; 864  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 865  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0007c	c6 45 d4 00	 mov	 BYTE PTR _filename$17[ebp], 0
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp

; 28   : 		GetExcutedFileName(filename);

  00080	8d 45 d4	 lea	 eax, DWORD PTR _filename$17[ebp]
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?GetExcutedFileName@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetExcutedFileName

; 29   : 
; 30   : 		MODULEENTRY32 me32;
; 31   : 		memset(&me32, 0, sizeof(me32));

  00090	68 20 02 00 00	 push	 544			; 00000220H
  00095	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _me32$16[ebp+4]
  0009b	6a 00		 push	 0
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _memset
  000a3	83 c4 10	 add	 esp, 16			; 00000010H

; 32   : 		me32.dwSize = sizeof(MODULEENTRY32);

  000a6	c7 85 a8 fd ff
	ff 24 02 00 00	 mov	 DWORD PTR _me32$16[ebp], 548 ; 00000224H

; 33   : 
; 34   : 		BOOL bRet = Module32First(hModuleSnap, &me32);

  000b0	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _me32$16[ebp]
  000b6	50		 push	 eax
  000b7	56		 push	 esi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Module32First@8

; 35   : 
; 36   : 		while (bRet) 

  000be	85 c0		 test	 eax, eax
  000c0	74 55		 je	 SHORT $LN3@GetProcess
  000c2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__Module32Next@8
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  000d0	83 7d e8 0f	 cmp	 DWORD PTR _filename$17[ebp+20], 15 ; 0000000fH

; 444  :         const value_type* _Result = _Bx._Buf;

  000d4	8d 55 d4	 lea	 edx, DWORD PTR _filename$17[ebp]
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp

; 38   : 			if (stristr(me32.szExePath, filename.c_str()))

  000d7	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _me32$16[ebp+288]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 445  :         if (_Large_mode_engaged()) {

  000dd	0f 47 55 d4	 cmova	 edx, DWORD PTR _filename$17[ebp]
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp

; 38   : 			if (stristr(me32.szExePath, filename.c_str()))

  000e1	e8 00 00 00 00	 call	 ?stristr@@YAPBDPBD0@Z	; stristr
  000e6	85 c0		 test	 eax, eax
  000e8	75 68		 jne	 SHORT $LN111@GetProcess

; 44   : 			}
; 45   : 
; 46   : 			ZeroMemory(&me32, sizeof(MODULEENTRY32));

  000ea	68 20 02 00 00	 push	 544			; 00000220H
  000ef	50		 push	 eax
  000f0	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR _me32$16[ebp+4]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _memset
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   : 			me32.dwSize = sizeof(MODULEENTRY32);

  000ff	c7 85 a8 fd ff
	ff 24 02 00 00	 mov	 DWORD PTR _me32$16[ebp], 548 ; 00000224H

; 48   : 
; 49   : 			bRet = Module32Next(hModuleSnap, &me32);

  00109	8d 85 a8 fd ff
	ff		 lea	 eax, DWORD PTR _me32$16[ebp]
  0010f	50		 push	 eax
  00110	56		 push	 esi
  00111	ff d7		 call	 edi
  00113	85 c0		 test	 eax, eax
  00115	75 b9		 jne	 SHORT $LL2@GetProcess
$LN3@GetProcess:

; 50   : 		}
; 51   : 
; 52   : 		CloseHandle(hModuleSnap);

  00117	56		 push	 esi
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  0011e	8b 4d e8	 mov	 ecx, DWORD PTR _filename$17[ebp+20]
  00121	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00124	0f 86 a5 00 00
	00		 jbe	 $LN96@GetProcess
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012a	8b 55 d4	 mov	 edx, DWORD PTR _filename$17[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0012d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00130	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00136	0f 82 89 00 00
	00		 jb	 $LN104@GetProcess

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0013c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0013f	83 c1 23	 add	 ecx, 35			; 00000023H
  00142	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00144	83 c0 fc	 add	 eax, -4			; fffffffcH
  00147	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0014a	0f 87 9f 00 00
	00		 ja	 $LN103@GetProcess
  00150	eb 73		 jmp	 SHORT $LN104@GetProcess
$LN111@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00152	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _me32$16[ebp+288]
  00158	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  0015b	0f 1f 44 00 00	 npad	 5
$LL115@GetProcess:
  00160	8a 02		 mov	 al, BYTE PTR [edx]
  00162	42		 inc	 edx
  00163	84 c0		 test	 al, al
  00165	75 f9		 jne	 SHORT $LL115@GetProcess
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00167	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR _exeFileName$GSCopy$1$[ebp]
  0016d	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _me32$16[ebp+288]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp

; 456  :             return __builtin_strlen(_First);

  00173	2b d7		 sub	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 1638 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00175	52		 push	 edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp

; 41   : 				*ppvAddress = me32.modBaseAddr;

  0017c	8b 8d a0 fd ff
	ff		 mov	 ecx, DWORD PTR _ppvAddress$GSCopy$1$[ebp]
  00182	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _me32$16[ebp+20]

; 42   : 				CloseHandle(hModuleSnap);

  00188	56		 push	 esi
  00189	89 01		 mov	 DWORD PTR [ecx], eax
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 453  :         return _Myres > _Small_string_capacity;

  00191	8b 4d e8	 mov	 ecx, DWORD PTR _filename$17[ebp+20]
  00194	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3083 :         if (_My_data._Large_mode_engaged()) {

  00197	76 28		 jbe	 SHORT $LN63@GetProcess
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00199	8b 55 d4	 mov	 edx, DWORD PTR _filename$17[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring

; 852  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0019c	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 985  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019d	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0019f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001a5	72 10		 jb	 SHORT $LN71@GetProcess

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001a7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001aa	83 c1 23	 add	 ecx, 35			; 00000023H
  001ad	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001af	83 c0 fc	 add	 eax, -4			; fffffffcH
  001b2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001b5	77 38		 ja	 SHORT $LN103@GetProcess
$LN71@GetProcess:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001b7	51		 push	 ecx
  001b8	52		 push	 edx
  001b9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001be	83 c4 08	 add	 esp, 8
$LN63@GetProcess:
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp

; 43   : 				return true;

  001c1	b0 01		 mov	 al, 1
  001c3	eb 0c		 jmp	 SHORT $LN1@GetProcess
$LN104@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  001c5	51		 push	 ecx
  001c6	52		 push	 edx
  001c7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001cc	83 c4 08	 add	 esp, 8
$LN96@GetProcess:
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp

; 55   : 	return false;

  001cf	32 c0		 xor	 al, al
$LN1@GetProcess:

; 56   : }

  001d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001db	59		 pop	 ecx
  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	33 cd		 xor	 ecx, ebp
  001e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	8b e3		 mov	 esp, ebx
  001ed	5b		 pop	 ebx
  001ee	c3		 ret	 0
$LN103@GetProcess:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ef	6a 00		 push	 0
  001f1	6a 00		 push	 0
  001f3	6a 00		 push	 0
  001f5	6a 00		 push	 0
  001f7	6a 00		 push	 0
  001f9	e8 00 00 00 00	 call	 __invoke_watson
$LN117@GetProcess:
  001fe	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _filename$17[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a a0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-608]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetProcessInformation@@YA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPBX@Z ENDP ; GetProcessInformation
; Function compile flags: /Ogtp
; File C:\Anka2Project\Anka2Project\Source\Binary\source\UserInterface\ProcessCRC.cpp
;	COMDAT ?GetProcessMemoryCRC@@YAKPBX@Z
_TEXT	SEGMENT
_dwBytesRead$ = -4					; size = 4
?GetProcessMemoryCRC@@YAKPBX@Z PROC			; GetProcessMemoryCRC, COMDAT
; _c_pvBaseAddress$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 60   : 	HANDLE hProcess = GetCurrentProcess();

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0

; 61   : 	char *pBuf = new char[1024*1024];

  0000f	68 00 00 10 00	 push	 1048576			; 00100000H
  00014	8b f0		 mov	 esi, eax
  00016	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b d8		 mov	 ebx, eax

; 62   : 	DWORD dwBytesRead;
; 63   : 
; 64   : 	BOOL bRet = ReadProcessMemory(hProcess, c_pvBaseAddress, pBuf, 1024*1024, &dwBytesRead);

  00020	8d 45 fc	 lea	 eax, DWORD PTR _dwBytesRead$[ebp]
  00023	50		 push	 eax
  00024	68 00 00 10 00	 push	 1048576			; 00100000H
  00029	53		 push	 ebx
  0002a	57		 push	 edi
  0002b	56		 push	 esi
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20

; 65   : 
; 66   : 	if (!bRet && GetLastError() == ERROR_PARTIAL_COPY)

  00032	85 c0		 test	 eax, eax
  00034	75 1f		 jne	 SHORT $LN5@GetProcess
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003c	3d 2b 01 00 00	 cmp	 eax, 299		; 0000012bH
  00041	74 12		 je	 SHORT $LN5@GetProcess

; 74   : 	}
; 75   : 
; 76   : 	delete [] pBuf;

  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00049	83 c4 04	 add	 esp, 4

; 77   : 	return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	5f		 pop	 edi

; 78   : }

  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN5@GetProcess:

; 67   : 		bRet = true;
; 68   : 
; 69   : 	if (bRet)
; 70   : 	{
; 71   : 		DWORD dwCRC = GetCRC32(pBuf, dwBytesRead);

  00055	ff 75 fc	 push	 DWORD PTR _dwBytesRead$[ebp]
  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32

; 72   : 		delete [] pBuf;

  0005e	53		 push	 ebx
  0005f	8b f0		 mov	 esi, eax
  00061	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   : 		return dwCRC;

  00069	8b c6		 mov	 eax, esi
  0006b	5f		 pop	 edi

; 78   : }

  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?GetProcessMemoryCRC@@YAKPBX@Z ENDP			; GetProcessMemoryCRC
_TEXT	ENDS
END
